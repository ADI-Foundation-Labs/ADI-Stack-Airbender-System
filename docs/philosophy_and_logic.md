# Philosophy and logic

Even though our purpose is to prove RISC-V bytecode execution per-se, we should understand that we effectively start mixing more and more code expressed in normal programming language + compiler assumptions + circuits. One side note for example is existence of the special "non-determinism" register abstraction, that is available for high-level programming language to access, and that can allow to make cheaper proofs of execution without(!) special circuits in some special cases, like hash-to-prime routine, where it's possible to compute some witnesses outside (same as often done in usual circuits), then provide them to the user's program, and verify by spending less cycles, than brute-force computation in the provable environment.

So, we have three programming models that we want to support, that rely on different degree of strictness and control over compiler output:
- standard example of kernel-mode program without special assumptions about the code and compiler features. So, RV32I+M instruction sets. It'll be a way to run ZKsyncOS itself. In this case we can in general assume correctness/good behavior of compiler, so we do not want to handle/trap cases like unaligned memory access. Standard compiler would not try to issue e.g. attempts to read `u32` at address that is not `0 mod 4` unless instructed otherwise. Note that none of the kernel-only (machine privilege only) configurations will support `ECALL/EBREAK/WFI` instructions due to efficiency (such instructions touch too many aspects of the internal machine state) and logic (well, we are in kernel - WHY do you need a `ECALL` to call any function, that is reachable by pointer in a system without MMU)
- for programs that we want to prove in practice there is no need to support signed multiplication/division opcodes, that take large part of the circuits, so there is a configuration like one above, but that doesn't support `DIV/REM/MULH/MULHSU` opcodes
- recursion-only mode where we very well control a compiler output of one single specific program. This way we can avoid supporting divisions/multiplications, less-than-word memory accesses, and provide handy ops like special opcodes (from `MOP` address space) for field arithmetics. It leads to both smaller circuit and less cycles to prove
- U-mode supporting case with memory translation support, where kernel (zkSync OS) can load arbitrary and untrusted RISC-V native bytecode from users. We would pay for that by having to implement memory translation, and smaller things like trap-handling, corresponding service registers, and implementing some timer, so external programs can not spend eternity in the infinite loop. RISC-V spec allows some variability in it, and since kernel (zkSync OS) is fully controlled, it's possible to choose circuit-efficient options

## Limitations over programs

- No support of the bytecode in generic RAM. We assume that bytecode is placed in memory subrange that is modeled as ROM
- No support runtime-loaded bytecode
- No loader - bytecode is dumped via `objdump`, and resulting flat binary is placed in the ROM. So there is no support of mutable non-trivially (non-zero) initialized variables. So EFL `.data` section is expected to be empty. Programs that do not use `static` variables are completely fine with that, and if such variable is needed it can be implemented via `MaybeUninit` in Rust terms, with manual initialization. Maybe we will spend some time to check what can be done better about it
- End of execution is checked by the verifier and requires particular behavior of the program - it must just loop at the end (implementation is provided via corresponding crate)
- In general we assume that intention of running the program is to show that it ended "successfully" - so it didn't panic at the end of the day (that would be unprovable circuit), but whether logical result of this program is "success" or "error" - is not for us to interpret

## Current state of the repo

Currently the version of the system presented in `main` branch is over-generalized. For example, every cycle contains a decoder logic, there opcode (as `u32`) is parsed to understand what instruction do we execute this cycle (or trap == unprovable circuit) otherwise. As we do not currently support the case of bytecode being located in RAM region of memory (any form of dynamic loading of the bytecode for execution), that would be the case if untrusted native RISC-V bytecode would be supported (that would also require U-mode support), we could instead model `text` section in ROM as jump a lookup of `PC -> fully decoded bytecode information` in circuits. There are some other places with similar inefficiencies.

In one of the branches there is another approach for state transition design, largely inspired by our RAM argument - we can model every cycle to be a state transition that maps internal machine state (in our case - it's just PC and timestamp) into another state (potentially touching memory along the way), with initial state (initial write set) being `(0, INITIAL_TS)`. At the end of the cycle we add `(final PC, final timestamp)` to write set, and `(initial PC, initial timestamp)` to the read set. Then we define a set of opcode-family specialized circuits, where `PC` is always looked up from the special table (generated from the bytecode), where only `PC` values with particular opcodes are present. This way we can have almost 100% efficient (every circuit variable participates in every opcode - it's a dream for all VM designs) circuit for `ADD/SUB`, another one for `MUL/DIV`, and so on. Optimizations from such approach can be backported into current approach (e.g. decoder table) almost in full as the current formulation of VM is needed for recursion purposes - at some point it's more efficient to go from "few different kinds(!) of circuits, each being more efficient -> less different kinds for less concrete number(!) of circuits to verify in recursion step"

## Small TODO list
- [ ] implement aligned arguments for parameter passing in precompiles
- [ ] backport decoder into current circuits